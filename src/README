1.
	In this part, clients and server communicate based on UDP/TCO protocol. All source files are written in C and utilize libraries provided on speclab. 
2.
	All the data process work is done on the server side. Server takes data, including an identifier, from different data respectively, invokes corresponding functions and send the results in string format back to clients. Clients then print out response from server directly.
	In the server, I created two linked lists to store the lists of voters and candidates specified by the clients. Each node of the lists represents individual voter or candidate which is a variable of Voter structure or Candidate structure. Voter structure entails an integer field to store the voter's id, a short type variable indicating whether he/she has voted or not and a pointer pointing to the next node. Candidate structure entails a string field for the name of the candidate, the number of votes he/she gets and a pointer pointing to the next node on the list. Whenever a new node is created, it will link to the head of the existent linkedlist(or NULL is the list is empty) and becomes the "head" of the list. Candidates with highest votes are collected in the tail of the list. Thus if a candidate node increments its votes, it will check the votes of node following it. If all the nodes following it has fewer votes, it goes to the end of the list. If it ties with a bunch of highest voted nodes, it goes to the position pointing to the first of those highes voted nodes. Note that I did not implement node exchange operations in this assignment. Instead, I only exchange contents of the node over positions on the list because clients only cares about contents.
	The logic of the server is following. It will first parse a 1-byte identifier sent from client, then goes into correct case in a switch-case loop. Next, the server parse out the message body (payload) from the client as parameters to execute its corresponding functions. It also forms the message client demands into string and send it back to client.
3.
	The clients' job is straightforward. It follows rules from the spec to take parameters from command line. Each client send a 1-byte identifier to the server to let it gets into different cases and send critical parameters to the server afterwards. For the sake of debugging's, when the client gets response from server, it prints out the message to standard output stream in the form of:
	"RESPONSE_FROM_SERVER" received from server, length: LENGTH_THAT_RECEIVED
4.
	All the strings that stores admin username, password and buffers used to store received or outgoing message are set at most 256 bytes (including terminate character). Since server only sends response once for each client request, we need to make sure the length of biggest response is with 256. This upperbound is set as a macro variable "BUF_SIZE" on top of each source file, so you need to modify that value mannually in order to bear bigger message.  
